name: Deploy .NET Azure Functions to Linux Consumption

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: deploy-func-petcatalog-prod
  cancel-in-progress: true

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: src/PetCatalog.Functions
  DOTNET_VERSION: 9.0.x
  AZURE_FUNCTIONAPP_NAME: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
  AZURE_RESOURCE_GROUP: rg-adoggami-prod
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  POSTGRES_DB: petcatalog

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          cache: false

      - name: Restore
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Wait for PostgreSQL & init DB
        env:
          PGPASSWORD: ${{ env.POSTGRES_PASSWORD }}
        run: |
          until pg_isready -h localhost -p 5432 -U $POSTGRES_USER; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          if [ -f "init-db/01-init.sql" ]; then
            psql -h localhost -U $POSTGRES_USER -d $POSTGRES_DB -f init-db/01-init.sql
          fi

      - name: Run unit tests
        run: dotnet test tests/PetCatalog.UnitTests --configuration Release --no-build --logger trx --results-directory TestResults

      - name: Run integration tests
        env:
          ConnectionStrings__DefaultConnection: "Host=localhost;Port=5432;Database=${{ env.POSTGRES_DB }};Username=${{ env.POSTGRES_USER }};Password=${{ env.POSTGRES_PASSWORD }}"
        run: dotnet test tests/PetCatalog.IntegrationTests --configuration Release --no-build --logger trx --results-directory TestResults

      - name: Publish Azure Functions
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          dotnet publish -c Release --no-self-contained --runtime linux-x64 -o ./output
          
          # Ensure host.json is in the output
          if [ -f "../host.json" ]; then
            cp ../host.json ./output/
          elif [ -f "host.json" ]; then
            cp host.json ./output/
          fi
          
          # Create deployment package
          cd output
          zip -r ../../deployment-package.zip .
          cd ../..
          
          echo "Package created: $(pwd)/deployment-package.zip"
          echo "Package size: $(du -h deployment-package.zip | cut -f1)"

      - name: Validate package structure
        run: |
          echo "=== Validating deployment package ==="
          unzip -l deployment-package.zip | head -30
          
          # Check for required files
          echo "=== Checking for required files ==="
          unzip -l deployment-package.zip | grep -E "host.json|\.dll|\.deps.json|\.runtimeconfig.json" || {
            echo "ERROR: Missing required files in package!"
            exit 1
          }
          
          # Verify host.json exists
          unzip -p deployment-package.zip host.json || {
            echo "ERROR: host.json not found in package!"
            exit 1
          }

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: functionapp-package
          path: |
            deployment-package.zip
            TestResults/**/*.trx

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    
    steps:
      - name: Download package
        uses: actions/download-artifact@v4
        with:
          name: functionapp-package
          path: .

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ env.ARM_CLIENT_ID }}",
              "clientSecret": "${{ env.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ env.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ env.ARM_TENANT_ID }}"
            }

      - name: Configure Function App for Linux Consumption
        run: |
          echo "=== Configuring Function App settings ==="
          
          # Get storage connection string
          STORAGE_CONNECTION=$(az storage account show-connection-string \
            --name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query connectionString -o tsv)
          
          # Set required app settings
          az functionapp config appsettings set \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            --settings \
              FUNCTIONS_WORKER_RUNTIME=dotnet-isolated \
              FUNCTIONS_EXTENSION_VERSION=~4 \
              AzureWebJobsStorage="$STORAGE_CONNECTION" \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false \
              ENABLE_ORYX_BUILD=false
          
          # Remove WEBSITE_RUN_FROM_PACKAGE if it exists (will be set to URL later)
          az functionapp config appsettings delete \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            --setting-names WEBSITE_RUN_FROM_PACKAGE || true
          
          echo "Waiting for settings to propagate..."
          sleep 10

      - name: Upload package to Azure Storage
        run: |
          echo "=== Uploading package to Azure Storage ==="
          
          # Create container if it doesn't exist
          az storage container create \
            --name "function-releases" \
            --account-name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --auth-mode login || true
          
          # Generate unique blob name with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BLOB_NAME="${{ env.AZURE_FUNCTIONAPP_NAME }}/$TIMESTAMP/deployment-package.zip"
          
          # Upload package
          az storage blob upload \
            --account-name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --container-name "function-releases" \
            --name "$BLOB_NAME" \
            --file deployment-package.zip \
            --auth-mode login \
            --overwrite
          
          # Generate SAS URL (valid for 5 years)
          END_DATE=$(date -u -d "5 years" '+%Y-%m-%dT%H:%MZ')
          
          PACKAGE_URL=$(az storage blob generate-sas \
            --account-name "${{ env.AZURE_STORAGE_ACCOUNT }}" \
            --container-name "function-releases" \
            --name "$BLOB_NAME" \
            --permissions r \
            --expiry "$END_DATE" \
            --auth-mode login \
            --full-uri -o tsv)
          
          echo "Package uploaded successfully"
          echo "PACKAGE_URL=$PACKAGE_URL" >> $GITHUB_ENV

      - name: Deploy to Linux Consumption Function App
        run: |
          echo "=== Deploying to Function App ==="
          
          # Update WEBSITE_RUN_FROM_PACKAGE with the blob URL
          az functionapp config appsettings set \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            --settings WEBSITE_RUN_FROM_PACKAGE="$PACKAGE_URL"
          
          echo "Deployment initiated. Waiting for app to sync..."
          sleep 20
          
          # Sync triggers
          echo "=== Syncing triggers ==="
          az functionapp function sync-triggers \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" || {
              echo "Warning: Sync triggers failed, but deployment may still succeed"
            }
          
          # Restart the function app
          echo "=== Restarting Function App ==="
          az functionapp restart \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}"
          
          echo "Waiting for restart to complete..."
          sleep 30

      - name: Verify deployment
        run: |
          echo "=== Verifying deployment ==="
          
          # Check app status
          STATUS=$(az functionapp show \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            --query "state" -o tsv)
          
          echo "Function App Status: $STATUS"
          
          # List functions (this might fail initially, but that's ok)
          echo "=== Attempting to list deployed functions ==="
          az functionapp function list \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            -o table || echo "Function list not available yet"
          
          # Get app URL
          APP_URL=$(az functionapp show \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --name "${{ env.AZURE_FUNCTIONAPP_NAME }}" \
            --query "defaultHostName" -o tsv)
          
          echo "Function App URL: https://$APP_URL"
          echo "Deployment completed successfully!"

      - name: Azure logout
        if: always()
        run: az logout